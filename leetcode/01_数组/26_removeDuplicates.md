# 26_删除排序数组中的重复项

> 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

> 示例 1:
>
> 给定数组 nums = [1,1,2], 
>
> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
>
> 你不需要考虑数组中超出新长度后面的元素。

>  示例 2:
>
> 给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
>
> 你不需要考虑数组中超出新长度后面的元素。

## 解：双指针

- 因为数组有序，所以如果有重复，也一定是相邻的
- **不需要考虑超出新长度后面的元素**，所以其实相当于把不重复的值都往前放
- 使用两个指针
  - 指针1从0开始，指针2从1开始
  - 比较两个指针所指的值是否相等，直至指针2到达数组尾端
    - 如果相等，说明是重复项，指针2直接后移，指针1不动
    - 如果不相等，说明不是重复项，指针2和指针1都后移一位，并且将这个值放到当前指针1的位置（也就是指针1向后移了一位的位置，也就是新数组的下一位）
  - 最后的结果，其实最后面几位仍然是原来的值，但题目说不用管，就不管了，只注意新数组长度内的那些就行了

``` cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() < 2)// 小于2个，就不用操作了，直接返回
        {
            return nums.size();
        }
        // i: 指针1
        // j: 指针2
        int i = 0;
        for(int j = 1; j<nums.size(); j++)
        {
            if(nums[j] != nums[i])// 不相等，说明不是重复项
            {
                i++;// 指针1和指针2都后移
                nums[i] = nums[j];// 把这个非重复项加进原数组
            }
            // 如果相等，说明是重复项，指针2直接后移，指针1不动
        }
        return i+1;// 返回的数组的新长度，i是索引，所以要加1 
    }
};
```

